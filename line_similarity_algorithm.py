# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LineSimilarity
                                 A QGIS plugin
 Calculate similarity between 2 lines
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-12-10
        copyright            : (C) 2020 by Julie Pierson, UMR 6554 LET, CNRS
        email                : julie.pierson@univ-brest.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Julie Pierson, UMR 6554 LETG, CNRS'
__date__ = '2020-12-10'
__copyright__ = '(C) 2020 by Julie Pierson, UMR 6554 LETG, CNRS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import math
import pandas as pd
import numpy as np
import plotly.express as px
from scipy import stats

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsMessageLog,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFolderDestination)

        
class LineSimilarityAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT1 = 'INPUT1'
    INPUT2 = 'INPUT2'
    ID_INPUT1 = 'ID_INPUT1'
    ID_INPUT2 = 'ID_INPUT2'
    OUTPUT_FOLDER = 'OUTPUT_FOLDER'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # input line layer 1
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT1,
                self.tr('First line layer'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        # input id field for line layer1
        self.addParameter(
            QgsProcessingParameterField(
                self.ID_INPUT1,
                self.tr('ID field for first line layer'),
                '',
                self.INPUT1
            )
        )
        # input line layer 2
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT2,
                self.tr('Second line layer'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        # input id field for line layer 2
        self.addParameter(
            QgsProcessingParameterField(
                self.ID_INPUT2,
                self.tr('ID field for second line layer'),
                '',
                self.INPUT2
            )
        )

        # output folder
        self.addParameter(
                QgsProcessingParameterFolderDestination(
                        self.OUTPUT_FOLDER, 
                            self.tr('Output folder'),
                            None, True))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve inputs and output
        layer1 = self.parameterAsVectorLayer(parameters, self.INPUT1, context)
        field1 = self.parameterAsString(parameters, self.ID_INPUT1, context)
        layer2 = self.parameterAsVectorLayer(parameters, self.INPUT2, context)
        field2 = self.parameterAsString(parameters, self.ID_INPUT2, context)
#        output_file = self.parameterAsFileOutput(parameters, self.OUTPUT_HTML_FILE, context)
        output_folder = self.parameterAsFile(parameters, self.OUTPUT_FOLDER, context)

        # LET'S GO !
        
        # calculate total length of lines in each layer, one dictionary per layer with one item for each line
        # lineLength = {"line1" : 21.2, "line2" : 14.3, ...}
        lineLength1 = self.getLength(layer1, field1)
        lineLength2 = self.getLength(layer2, field2)
        QgsMessageLog.logMessage(('lineLength1 : ' + str(lineLength1)), 'LineSimilarity')
        QgsMessageLog.logMessage(('lineLength2 : ' + str(lineLength2)), 'LineSimilarity')
        
        # retrieves list of line ids from lineLength dictionaries
        lineIds1 = lineLength1.keys()
        lineIds2 = lineLength2.keys()
        QgsMessageLog.logMessage(('lineIds1 : ' + str(lineIds1)), 'LineSimilarity')
        QgsMessageLog.logMessage(('lineIds2 : ' + str(lineIds2)), 'LineSimilarity')
        
        # get all vertex coordinates of lines in each layer, one dictionary per layer with one list for each line
        # pointsCoord = {"line1" : [[xA, yA], [xB, yB], ...], "line2" : [[xA, yA], [xB, yB], ...], ...}
        pointsCoord1 = self.getPointsCoord(layer1, field1)
        pointsCoord2 = self.getPointsCoord(layer2, field2)
        QgsMessageLog.logMessage(('pointsCoord1 : ' + str(pointsCoord1)), 'LineSimilarity')
        QgsMessageLog.logMessage(('pointsCoord2 : ' + str(pointsCoord2)), 'LineSimilarity')
        
        # get for each vertex except 1st and last its distance between 0 and 1 and its angle
        # lineLength = {"line1" : [[0.12, 94], [0.25, 178], ..., [0.93, 134]], "line2" : [[0.09, 88], [0.28, 192], ..., [0.95, 129]], ...}
        pointInfos1 = self.getPointInfo(lineIds1, pointsCoord1, lineLength1)
        pointInfos2 = self.getPointInfo(lineIds2, pointsCoord2, lineLength2)
        QgsMessageLog.logMessage(('pointInfos1 : ' + str(pointInfos1)), 'LineSimilarity')
        QgsMessageLog.logMessage(('pointInfos2 : ' + str(pointInfos2)), 'LineSimilarity')
        
        # create dataframe with 4 columns from these infos : distance, angle, line id and layer name
        df, df1, df2 = self.createDataframe(pointInfos1, pointInfos2, layer1.name(), layer2.name())
        
        # create plots for each line, distance as x and angle as y, color for layer
        # this step is optional, only for visualising results
        self.plotLine(df)
        
        # create one dataframe for each layer, 1 column position + as many columns as lines for angle
        dfCorr1, dfCorr2 = self.getYvalues(df, df1, df2, layer1.name(), layer2.name())
        QgsMessageLog.logMessage(('dfCorr1 : ' + str(dfCorr1)), 'LineSimilarity')
        QgsMessageLog.logMessage(('dfCorr2 : ' + str(dfCorr2)), 'LineSimilarity')
        
        # empty dictionary for results
        results = {}
        
        # calculate spearman coefficient and p-value
        statSpearman, pvalueSpearman = self.corrSpearman(dfCorr1, dfCorr2)
        results['Spearman'] = statSpearman
        results['p-value Spearman'] = pvalueSpearman
        
#        # calculate Shapiro test and p-value
#        statShapiro, pvalueShapiro = self.shapiroTest(dfCorr)
#        results['Shapiro'] = statShapiro
#        results['p-value Shapiro'] = pvalueShapiro
#        
#        # calculate Student test and p-value
#        statStudent, pvalueStudent = self.studentTest(dfCorr)
#        results['Sudent'] = statStudent
#        results['p-value Student'] = pvalueStudent
#        
#        # calculate Student test and p-value
#        statWilcoxon, pvalueWilcoxon = self.wilcoxonTest(dfCorr)
#        results['Wilcoxon'] = statWilcoxon
#        results['p-value Wilcoxon'] = pvalueWilcoxon
        
        # reurn results
        if output_folder:
#            self.createHTML(output_file, results, layer1.name(), layer2.name())
#            results[self.OUTPUT_HTML_FILE] = output_file
            # array for each layer
            self.createCSV(output_folder, layer1.name(), dfCorr1)
            self.createCSV(output_folder, layer2.name(), dfCorr2)
            for key, value in results.items():
                self.createCSV(output_folder, key, value)

        return results
    
    # get total length of all lines in a line layer
    # lineLength = {"line1" : 21.2, "line2" : 14.3, ...}
    def getLength(self, lineLayer, idField):
        lineLength = {}
        features = lineLayer.getFeatures()
        for f in features:
            idValue = f[idField]
            geom = f.geometry()
            lineLength[idValue] = geom.length()
        return lineLength
    
    # get vertex coordinates from all lines in a line layer
    # {"line1" : [[xA, yA], [xB, yB], ...], "line2" : [[xA, yA], [xB, yB], ...], ...}
    def getPointsCoord(self, lineLayer, idField):
        pointsCoords = {}
        features = lineLayer.getFeatures()
        for f in features:
            idValue = f[idField]
            geom = f.geometry()
            pl = geom.asPolyline()
            pointsCoords[idValue] = [[point.x(), point.y()] for point in pl]
        return pointsCoords
    
    # calculate angle at b from 3 points coordinates a, b and c where each point = [x, y]
    # angle is measured anti-clockwise
    # https://manivannan-ai.medium.com/find-the-angle-between-three-points-from-2d-using-python-348c513e2cd
    def getAngle(self, a, b, c):
        ang = math.degrees(math.atan2(c[1]-b[1], c[0]-b[0]) - math.atan2(a[1]-b[1], a[0]-b[0]))
        return ang + 360 if ang < 0 else ang
    
    # calculate the distance between 2 points a, b where each point = [x, y]
    def getDistance(self, a, b):
        distance = math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)
        return distance
    
    # get for each vertex except first and last its position and its angle
    # position is between 0 and 1, with 0 = 1st vertex and 1 = last vertex
    # angle gets calculated with getAngle function
    # result is a dictionary, each item a list where each element = [position, angle]
    # {"line1" : [[0.12, 94], [0.25, 178], ..., [0.93, 134]], "line2" : [[0.09, 88], [0.28, 192], ..., [0.95, 129]], ...}
    def getPointInfo(self, lineIds, pointsCoord, lineLength):
        pointInfos = {k:[] for k in lineIds}
        # for each line
        for key, value in pointsCoord.items():
            distance = 0
            # for each point except 1st and last
            for i, point in enumerate(value[1:-1]):
                # calculates distance to previous vertex
                distToPreviousPoint = self.getDistance(point, value[i])
                # adds it to previous calculated distance
                distance = distance + distToPreviousPoint
                # standardise distance between 0 and 1
                distanceStandardised = distance / lineLength[key]
                # calculate angle between previous vertex, vertex and next vertex
                angle = self.getAngle(value[i], point, value[i+2])
                # stores the distance and angle for each vertex
                pointInfos[key].append([distanceStandardised, angle])
        return pointInfos
    
    # create dataframe from the infos of the 2 line layers
    # 4 columns : distance, angle, line id and layer name
    def createDataframe(self, pointInfos1, pointInfos2, layerName1, layerName2):
        # data frame for 1st layer
        lrows1 = []
        for key in pointInfos1.keys():
            for point in pointInfos1[key]:
                currentDict = {"layer": layerName1, "line id": key, "distance": point[0], "angle": point[1]}
                lrows1.append(currentDict)
        df1 = pd.DataFrame(lrows1)
        # dataframe for 2nd layer
        lrows2 = []
        for key in pointInfos2.keys():
            for point in pointInfos2[key]:
                currentDict = {"layer": layerName2, "line id": key, "distance": point[0], "angle": point[1]}
                lrows2.append(currentDict)
        df2 = pd.DataFrame(lrows2)
        df = pd.concat([df1, df2])
        return df, df1, df2
    
    # create line plot with distance as x and angle as y, for the 2 layers
    # this step is optional, only for visualising results
    def plotLine(self, df):
        # create plot
        fig = px.line(df, x = "distance", y = "angle", color = "layer", line_group = "line id", hover_name = "line id")
        # sets min, max and step for the axes
        fig.update_layout(xaxis_range=[0, 1])
        fig.update_layout(yaxis_range=[0, 360])
        fig.update_yaxes(tick0=0, dtick=45)
        # show plot in web browser
        fig.show()
     
    # gets all x values of all line in both layers
    # and calculates corresponding y values for each line in each layer
    # output is a dataframe for each layer,
    # with one column for position (x) and as many columns as lines in the layer for angles (y)
    def getYvalues(self, df, df1, df2, layerName1, layerName2):
        dfCorr1 = pd.DataFrame()
        dfCorr2 = pd.DataFrame()
        # get all x values with no duplicates
        allX = list(set(df['distance']))
        dfCorr1['x'] = allX
        dfCorr2['x'] = allX
        # add one column for each line for layer 1
        for line in df1['line id']:
            # create a dataframe for the current line
            dfline = df1[df1['line id'] == line]
            # retrieve x and y values for the current line
            xline = dfline['distance']
            yline = dfline['angle']
            # interpolates angle values for all x values
            dfCorr1[line] = [np.interp(x, xline, yline) for x in allX]
        # add one column for each line for layer2
        for line in df2['line id']:
            # create a dataframe for the current line
            dfline = df2[df2['line id'] == line]
            # retrieve x and y values for the current line
            xline = dfline['distance']
            yline = dfline['angle']
            # interpolates angle values for all x values
            dfCorr2[line] = [np.interp(x, xline, yline) for x in allX]
        return dfCorr1, dfCorr2
        
    # calculate correlation between the 2 variables with Spearman coefficient
    def corrSpearman(self, dfCorr1, dfCorr2):
        # supprime la colonne x de chaque dataframe
        dfSpearman1 = dfCorr1.drop(columns = ['x'])
        dfSpearman2 = dfCorr2.drop(columns = ['x'])
        # convertit le dataframe en array numpy
        arraySpearman1 = dfSpearman1.values
        arraySpearman2 = dfSpearman2.values
        # Spearman
        statSpearman, pvalueSpearman = stats.spearmanr(arraySpearman1, arraySpearman2)
        return statSpearman, pvalueSpearman
    
    # calculate Shapiro test to know if it's ok to proceed with Student test
    def shapiroTest(self, dfCorr):
        dfShapiro = pd.concat([dfCorr['y1'], dfCorr['y2']], axis = 1, keys=['y1', 'y2'])
        statShapiro, pvalueShapiro = stats.shapiro(dfShapiro)
        return statShapiro, pvalueShapiro
    
    # calculate correlation between the 2 variables with paired Student test
    def studentTest(self, dfCorr):
        statStudent, pvalueStudent = stats.ttest_rel(dfCorr['y1'], dfCorr['y2'])
        return statStudent, pvalueStudent
    
    # calculate correlation between the 2 variables with Wilcoxon test
    def wilcoxonTest(self, dfCorr):
        statWilcoxon, pvalueWilcoxon = stats.wilcoxon(dfCorr['y1'], dfCorr['y2'])
        return statWilcoxon, pvalueWilcoxon
    
    # create CSV file form result array
    def createCSV(self, output_folder, csv_name, csv_content):
        csv_file = output_folder + '/' + csv_name + ".csv"
        #np.savetxt(csv_name, csv_content, delimiter=",")
        pd.DataFrame(csv_content).to_csv(csv_file)
    
#    def createHTML(self, outputFile, results, layer1, layer2):
#        with codecs.open(outputFile, 'w', encoding='utf-8') as f:
#            f.write('<html><head>\n')
#            f.write('<meta http-equiv="Content-Type" content="text/html; \
#                    charset=utf-8" /></head><body>\n')
#            entete = 'calcul de similarit√© entre %s et %s :\n' % (layer1, layer2)
#            f.write(entete)
#            for k, v in results.items():
#                f.write('<p>' + str(k) + ' : ' + str(v) + '</p>\n')
#            f.write('</body></html>\n')
            
    def shortHelpString(self):
        return self.tr('''This algorithm takes 2 line layers as input, with only 1 entity in each layer. Layers are standardised and then compared using spearman correlation coefficient. Output is spearman coefficient and p-value, and a plot of the 2 standardised lines. The result is independant of rotation, scale and translation.''')
    
    def helpUrl(self):
        return "https://github.com/juliepierson/qgis_line_similarity"

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Line similarity'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LineSimilarityAlgorithm()
