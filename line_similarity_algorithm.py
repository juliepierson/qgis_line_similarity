# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LineSimilarity
                                 A QGIS plugin
 Calculate similarity between 2 lines
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-12-10
        copyright            : (C) 2020 by Julie Pierson, UMR 6554 LET, CNRS
        email                : julie.pierson@univ-brest.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Julie Pierson, UMR 6554 LETG, CNRS'
__date__ = '2020-12-10'
__copyright__ = '(C) 2020 by Julie Pierson, UMR 6554 LETG, CNRS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import codecs
import math
import pandas as pd
import numpy as np
import plotly.express as px
from scipy import stats

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterFileDestination)

        
class LineSimilarityAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT1 = 'INPUT1'
    INPUT2 = 'INPUT2'
    OUTPUT_HTML_FILE = 'OUTPUT_HTML_FILE'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # input line layers
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT1,
                self.tr('First line layer'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT2,
                self.tr('Second line layer'),
                [QgsProcessing.TypeVectorLine]
            )
        )

        # html output
        self.addParameter(
                QgsProcessingParameterFileDestination(
                        self.OUTPUT_HTML_FILE, 
                            self.tr('Statistics'),
                            self.tr('HTML files (*.html)'), 
                            None, True))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        # Retrieve inputs and output
        layer1 = self.parameterAsVectorLayer(parameters, self.INPUT1, context)
        layer2 = self.parameterAsVectorLayer(parameters, self.INPUT2, context)
        output_file = self.parameterAsFileOutput(parameters, self.OUTPUT_HTML_FILE, context)

        # LET'S GO !
        
        # calculate total length of line in each layer
        lineLength1 = self.getLength(layer1)
        lineLength2 = self.getLength(layer2)
        
        # get all vertex coordinates in each layer
        pointsCoord1 = self.getPointsCoord(layer1)
        pointsCoord2 = self.getPointsCoord(layer2)
        
        # get for each vertex except 1st and last its distance between 0 and 1 and its angle
        pointInfos1 = self.getPointInfo(pointsCoord1, lineLength1)
        pointInfos2 = self.getPointInfo(pointsCoord2, lineLength2)
        
        # create dataframe with 3 columns from these infos : distance, angle and layer name
        df = self.createDataframe(pointInfos1, pointInfos2, layer1.name(), layer2.name())
        
        # create plots for the 2 lines, distance as x and angle as y
        # this step is optional, only for visualising results
        self.plotLine(df)
        
        # create dataframe used to calculate correlation, 3 columns x, y1 for layer1 and y2 for layer2
        dfCorr = self.getYvalues(df, layer1.name(), layer2.name())
        
        # calculate spearman coefficient and p-value
        cor, pvalue = self.calculateCorr(dfCorr)
        results = {'Spearman' : cor, 'p-value' : pvalue}
        
        # reurn results
        if output_file:
            self.createHTML(output_file, results, layer1.name(), layer2.name())
            results[self.OUTPUT_HTML_FILE] = output_file

        return results
    
    # get total length of the line in a line layer
    def getLength(self, lineLayer):
        features = lineLayer.getFeatures()
        for f in features:
            geom = f.geometry()
        length = geom.length()
        return length
    
    # get vertex coordinates from a line, as a list of list
    # [[xA, yA], [xB, yB], ...]
    def getPointsCoord(self, lineLayer):
        features = lineLayer.getFeatures()
        for f in features:
            geom = f.geometry()
        pl = geom.asPolyline()
        pointsCoords = [[point.x(), point.y()] for point in pl]
        return pointsCoords
    
    # calculate angle from 3 points coordinates a, b and c where each point = [x, y]
    # angle is measured anti-clockwise
    # https://manivannan-ai.medium.com/find-the-angle-between-three-points-from-2d-using-python-348c513e2cd
    def getAngle(self, a, b, c):
        ang = math.degrees(math.atan2(c[1]-b[1], c[0]-b[0]) - math.atan2(a[1]-b[1], a[0]-b[0]))
        return ang + 360 if ang < 0 else ang
    
    # calculate the distance between 2 points a, b where each point = [x, y]
    def getDistance(self, a, b):
        distance = math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)
        return distance
    
    # get for each vertex except first and last its position and its angle
    # position is between 0 and 1, with 0 = 1st vertex and 1 = last vertex
    # angle gets calculated with getAngle function
    # result is list of list, each element = [position, angle]
    # [[0.12, 94], [0.25, 178], ..., [0.93, 134]]
    def getPointInfo(self, pointCoords, lineLength):
        pointInfos = []
        distance = 0
        # for each point except 1st and last
        for i, point in enumerate(pointCoords[1:-1]):
            # calculates distance to previous vertex
            distToPreviousPoint = self.getDistance(point, pointCoords[i])
            # adds it to previous calculated distance
            distance = distance + distToPreviousPoint
            # standardise distance between 0 and 1
            distanceStandardised = distance / lineLength
            # calculate angle between previous vertex, vertex and next vertex
            angle = self.getAngle(pointCoords[i], point, pointCoords[i+2])
            # stores the distance and angle for each vertex
            pointInfos.append([distanceStandardised, angle])
        return pointInfos
    
    # create dataframe from the infos of the 2 line layers
    # 3 columns : distance, angle and layer name
    def createDataframe(self, pointInfos1, pointInfos2, layerName1, layerName2):
        df1 = pd.DataFrame(pointInfos1, columns = ["distance", "angle"])
        df1["layer"] = layerName1
        df2 = pd.DataFrame(pointInfos2, columns = ["distance", "angle"])
        df2["layer"] = layerName2
        df = pd.concat([df1, df2])
        return df
    
    # create line plot with distance as x and angle as y, for the 2 layers
    # this step is optional, only for visualising results
    def plotLine(self, df):
        # create plot
        fig = px.line(df, x = "distance", y = "angle", color = "layer")
        # sets min, max and step for the axes
        fig.update_layout(xaxis_range=[0, 1])
        fig.update_layout(yaxis_range=[0, 360])
        fig.update_yaxes(tick0=0, dtick=45)
        # show plot in web browser
        fig.show()
     
    # gets all x values of the 2 layers
    # and calculates corresponding y values for each layer
    # output is a dataframe with 3 columns : x, y1 and y2 where y1 is for layer1 and y2 for layer2
    def getYvalues(self, df, layerName1, layerName2):
        dfCorr = pd.DataFrame()
        dfCorr['x'] = df['distance']
        xLayer1 = df[df['layer'] == layerName1]['distance']
        yLayer1 = df[df['layer'] == layerName1]['angle']
        dfCorr['y1'] = [np.interp(x, xLayer1, yLayer1) for x in dfCorr['x']]
        xLayer2 = df[df['layer'] == layerName2]['distance']
        yLayer2 = df[df['layer'] == layerName2]['angle']
        dfCorr['y2'] = [np.interp(x, xLayer2, yLayer2) for x in dfCorr['x']]
        return dfCorr
        
    # calculate correlation between the 2 variables with Spearman coefficient
    def calculateCorr(self, dfCorr):
        cor, pvalue = stats.spearmanr(dfCorr['y1'], dfCorr['y2'])
        return cor, pvalue
    
    def createHTML(self, outputFile, results, layer1, layer2):
        with codecs.open(outputFile, 'w', encoding='utf-8') as f:
            f.write('<html><head>\n')
            f.write('<meta http-equiv="Content-Type" content="text/html; \
                    charset=utf-8" /></head><body>\n')
            entete = 'calcul de similarité entre %s et %s :\n' % (layer1, layer2)
            f.write(entete)
            for k, v in results.items():
                f.write('<p>' + str(k) + ' : ' + str(v) + '</p>\n')
            f.write('</body></html>\n')


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Line similarity'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LineSimilarityAlgorithm()
