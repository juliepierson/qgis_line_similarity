# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LineSimilarity
                                 A QGIS plugin
 Calculate similarity between 2 lines
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-12-10
        copyright            : (C) 2020 by Julie Pierson, UMR 6554 LET, CNRS
        email                : julie.pierson@univ-brest.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Julie Pierson, UMR 6554 LETG, CNRS'
__date__ = '2020-12-10'
__copyright__ = '(C) 2020 by Julie Pierson, UMR 6554 LETG, CNRS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import math
import pandas as pd
import numpy as np
import plotly.express as px
from scipy import stats

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsMessageLog,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterVectorLayer,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFolderDestination,
                       QgsProperty,
                       QgsProject,
                       QgsVectorLayer,
                       QgsProcessingOutputMultipleLayers,
                       QgsProcessingContext)
import processing
import qgis.utils

        
class LineSimilarityAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT1 = 'INPUT1'
    INPUT2 = 'INPUT2'
    ID_INPUT1 = 'ID_INPUT1'
    ID_INPUT2 = 'ID_INPUT2'
    OUTPUT_FOLDER = 'OUTPUT_FOLDER'
    OUTPUT_LAYERS = 'OUTPUT_LAYERS'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # input line layer 1
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT1,
                self.tr('First line layer'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        # input id field for line layer1
        self.addParameter(
            QgsProcessingParameterField(
                self.ID_INPUT1,
                self.tr('ID field for first line layer'),
                '',
                self.INPUT1
            )
        )
        # input line layer 2
        self.addParameter(
            QgsProcessingParameterVectorLayer(
                self.INPUT2,
                self.tr('Second line layer'),
                [QgsProcessing.TypeVectorLine]
            )
        )
        # input id field for line layer 2
        self.addParameter(
            QgsProcessingParameterField(
                self.ID_INPUT2,
                self.tr('ID field for second line layer'),
                '',
                self.INPUT2
            )
        )

        # output folder for CSV
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_FOLDER, 
                self.tr('Output folder for statistic results (CSV)'),
                None, True))
        
        # output layers
        self.addOutput(
            QgsProcessingOutputMultipleLayers(
                self.OUTPUT_LAYERS,
                self.tr('Output layers')
            )
        )


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        
        interval = 1000 # TODO : make it a parameter

        # Retrieve inputs and output
        layer1 = self.parameterAsVectorLayer(parameters, self.INPUT1, context)
        field1 = self.parameterAsString(parameters, self.ID_INPUT1, context)
        layer2 = self.parameterAsVectorLayer(parameters, self.INPUT2, context)
        field2 = self.parameterAsString(parameters, self.ID_INPUT2, context)
#        output_file = self.parameterAsFileOutput(parameters, self.OUTPUT_HTML_FILE, context)
        output_folder = self.parameterAsFile(parameters, self.OUTPUT_FOLDER, context)

        # LET'S GO !
        
        # calculate total length of lines in each layer, one dictionary per layer with one item for each line
        # lineLength = {"line1" : 21.2, "line2" : 14.3, ...}
        lineLength1 = self.getLength(layer1, field1)
        lineLength2 = self.getLength(layer2, field2)
        #QgsMessageLog.logMessage(('lineLength1 : ' + str(lineLength1)), 'LineSimilarity')
        #QgsMessageLog.logMessage(('lineLength2 : ' + str(lineLength2)), 'LineSimilarity')
        
        # retrieves list of line ids from lineLength dictionaries
        lineIds1 = lineLength1.keys()
        lineIds2 = lineLength2.keys()
        # TODO : check that lineIds1 and lineIds2 are the same
        
        # densify line vertexes so that each line in layer 1 gets one vertex every chosen interval
        # and each line in layer 2 get as many vertex as line with same id in layer 1
        layer1DensifyPt, layer2DensifyPt = self.densifyLines(layer1, layer2, field2, lineLength1, lineLength2, interval, context, feedback)
        
        # create line layer from point layers layer1densify and layer2densify
        layer1densifyLn = self.lineFromPoint(layer1DensifyPt, field1, "layer 1 densify line", context, feedback)
        layer2densifyLn = self.lineFromPoint(layer2DensifyPt, field2, "layer 2 densify line", context, feedback)
        
        # get all vertex coordinates of lines in each layer, one dictionary per layer with one list for each line
        # pointsCoord = {"line1" : [[xA, yA], [xB, yB], ...], "line2" : [[xA, yA], [xB, yB], ...], ...}
        pointsCoord1 = self.getPointsCoord(layer1densifyLn, field1)
        pointsCoord2 = self.getPointsCoord(layer2densifyLn, field2)
        #QgsMessageLog.logMessage(('pointsCoord1 : ' + str(pointsCoord1)), 'LineSimilarity')
        #QgsMessageLog.logMessage(('pointsCoord2 : ' + str(pointsCoord2)), 'LineSimilarity')
        
        # get for each vertex except 1st and last its distance between 0 and 1 and its angle
        # lineLength = {"line1" : [[0.12, 94], [0.25, 178], ..., [0.93, 134]], "line2" : [[0.09, 88], [0.28, 192], ..., [0.95, 129]], ...}
        pointInfos1 = self.getPointInfo(lineIds1, pointsCoord1, lineLength1)
        pointInfos2 = self.getPointInfo(lineIds2, pointsCoord2, lineLength2)
        #QgsMessageLog.logMessage(('pointInfos1 : ' + str(pointInfos1)), 'LineSimilarity')
        #QgsMessageLog.logMessage(('pointInfos2 : ' + str(pointInfos2)), 'LineSimilarity')
        
        # create dataframe with 4 columns from these infos : distance, angle, line id and layer name
        df, df1, df2 = self.createDataframe(pointInfos1, pointInfos2, layer1.name(), layer2.name())
        
        # create plots for each line, distance as x and angle as y, 
        # TODO : continuous line for layer 1 and dots for layer 2, same color for same id
        # this step is optional, only for visualising results
        self.plotLine(df)
        
        # create one result dataframe : 1st column for line id, next columns for stat results
        dfResults = self.getStatResults(df1, df2, lineIds1)
        
        # calculate spearman coefficient and p-value
#        statSpearman, pvalueSpearman = self.corrSpearman(dfCorr1, dfCorr2)
#        results['Spearman'] = statSpearman
#        results['p-value Spearman'] = pvalueSpearman
        
#        # calculate Shapiro test and p-value
#        statShapiro, pvalueShapiro = self.shapiroTest(dfCorr)
#        results['Shapiro'] = statShapiro
#        results['p-value Shapiro'] = pvalueShapiro
#        
#        # calculate Student test and p-value
#        statStudent, pvalueStudent = self.studentTest(dfCorr)
#        results['Sudent'] = statStudent
#        results['p-value Student'] = pvalueStudent
#        
#        # calculate Student test and p-value
#        statWilcoxon, pvalueWilcoxon = self.wilcoxonTest(dfCorr)
#        results['Wilcoxon'] = statWilcoxon
#        results['p-value Wilcoxon'] = pvalueWilcoxon
        
        # reurn results
        if output_folder:
            # create csv from dataframe, in output folder
            self.createCSV(output_folder, "toto", dfResults)

        return {}
    
    # get total length of all lines in a line layer
    # lineLength = {"line1" : 21.2, "line2" : 14.3, ...}
    def getLength(self, lineLayer, idField):
        lineLength = {}
        features = lineLayer.getFeatures()
        for f in features:
            idValue = f[idField]
            geom = f.geometry()
            lineLength[idValue] = geom.length()
        return lineLength
    
    def densifyLines(self, layer1, layer2, field2, lineLength1, lineLength2, distance, context, feedback):
        # add vertex at given interval (distance parameter) for layer 1 with pointsalonglines processing algorithm
        param1 = {'INPUT':layer1,
                  'DISTANCE':distance,
                  'START_OFFSET':0,
                  'END_OFFSET':0,
                  'OUTPUT':'layer 1 densify'}
        res = processing.run("native:pointsalonglines", param1, context=context, feedback=feedback)
        layer1densify = res['OUTPUT']
        # count vertex for each line in layer 1
        nbVertexLayer1 = {}
        for key, value in lineLength1.items():
            nbVertexLayer1[key] = math.floor(value / distance) + 1
        # get intervals at which points must be created in layer 2 
        # so that each line gets as many vertex as line with same id in layer1
        intervalLayer2 = {}
        for key, value in nbVertexLayer1.items():
            intervalLayer2[key] = math.floor(lineLength2[key] / value) + 1
        # add vertex for layer 2 with pointsalongline processing algorithm
        mymap = []
        for k, v in intervalLayer2.items():
            mymap.extend([k, v])
        mymap = tuple(mymap)
        param2 = {'INPUT':layer2,
                  'DISTANCE': QgsProperty.fromExpression("map_get(map{}, {})".format(str(mymap), field2)) ,
                  'START_OFFSET':0,
                  'END_OFFSET':0,
                  'OUTPUT':'layer 2 densify'}
        res = processing.run("native:pointsalonglines", param2, context=context, feedback=feedback)
        layer2densify = res['OUTPUT']
        # load the new densified layers
        # https://gis.stackexchange.com/a/343404
        layer1densify = QgsVectorLayer(layer1densify, "layer 1 densify", "ogr")
        layer2densify = QgsVectorLayer(layer2densify, "layer 2 densify", "ogr")
#        output_layers = []
#        output_layers.extend([layer1densify, layer2densify])
#        context.temporaryLayerStore().addMapLayers([layer1densify, layer2densify])
#        context.addLayerToLoadOnCompletion(
#            layer1densify.id(),
#            QgsProcessingContext.LayerDetails(
#                'layer name',
#                context.project(),
#                self.OUTPUT_LAYERS
#            )
#        )
#        context.addLayerToLoadOnCompletion(
#            layer2densify.id(),
#            QgsProcessingContext.LayerDetails(
#                'layer name',
#                context.project(),
#                self.OUTPUT_LAYERS
#            )
#        )
        #return {self.OUTPUT_LAYERS: output_layers}
        return layer1densify, layer2densify
    
    def lineFromPoint(self, layerDensifyPt, idfield, layername, context, feedback):
        # run pointstopath algorithm
        param = {'INPUT': layerDensifyPt,
                  'CLOSE_PATH': False,
                  'ORDER_FIELD': 'distance',
                  'GROUP_FIELD': idfield,
                  'DATE_FORMAT': '',
                  'OUTPUT': layername}
        res = processing.run("qgis:pointstopath", param, context=context, feedback=feedback)
        layerDensifyLn = res['OUTPUT']
        # load resulting layer
        layerDensifyLn = QgsVectorLayer(layerDensifyLn, layername, "ogr")
        output_layers = []
        output_layers.append(layerDensifyLn)
        context.temporaryLayerStore().addMapLayer(layerDensifyLn)
        context.addLayerToLoadOnCompletion(
            layerDensifyLn.id(),
            QgsProcessingContext.LayerDetails(
                'layer name',
                context.project(),
                self.OUTPUT_LAYERS
            )
        )
        return layerDensifyLn
    
    # get vertex coordinates from all lines in a line layer
    # {"line1" : [[xA, yA], [xB, yB], ...], "line2" : [[xA, yA], [xB, yB], ...], ...}
    def getPointsCoord(self, lineLayer, idField):
        pointsCoords = {}
        features = lineLayer.getFeatures()
        for f in features:
            idValue = f[idField]
            geom = f.geometry()
            pl = geom.asPolyline()
            pointsCoords[idValue] = [[point.x(), point.y()] for point in pl]
        return pointsCoords
    
    # calculate angle at b from 3 points coordinates a, b and c where each point = [x, y]
    # angle is measured anti-clockwise
    # https://manivannan-ai.medium.com/find-the-angle-between-three-points-from-2d-using-python-348c513e2cd
    def getAngle(self, a, b, c):
        ang = math.degrees(math.atan2(c[1]-b[1], c[0]-b[0]) - math.atan2(a[1]-b[1], a[0]-b[0]))
        return ang + 360 if ang < 0 else ang
    
    # calculate the distance between 2 points a, b where each point = [x, y]
    def getDistance(self, a, b):
        distance = math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)
        return distance
    
    # get for each vertex except first and last its position and its angle
    # position is between 0 and 1, with 0 = 1st vertex and 1 = last vertex
    # angle gets calculated with getAngle function
    # result is a dictionary, each item a list where each element = [position, angle]
    # {"line1" : [[0.12, 94], [0.25, 178], ..., [0.93, 134]], "line2" : [[0.09, 88], [0.28, 192], ..., [0.95, 129]], ...}
    def getPointInfo(self, lineIds, pointsCoord, lineLength):
        pointInfos = {k:[] for k in lineIds}
        # for each line
        for key, value in pointsCoord.items():
            distance = 0
            # for each point except 1st and last
            for i, point in enumerate(value[1:-1]):
                # calculates distance to previous vertex
                distToPreviousPoint = self.getDistance(point, value[i])
                # adds it to previous calculated distance
                distance = distance + distToPreviousPoint
                # standardise distance between 0 and 1
                distanceStandardised = distance / lineLength[key]
                # calculate angle between previous vertex, vertex and next vertex
                angle = self.getAngle(value[i], point, value[i+2])
                # stores the distance and angle for each vertex
                pointInfos[key].append([distanceStandardised, angle])
        return pointInfos
    
    # create dataframe from the infos of the 2 line layers
    # 4 columns : distance, angle, line id and layer name
    def createDataframe(self, pointInfos1, pointInfos2, layerName1, layerName2):
        # data frame for 1st layer
        lrows1 = []
        for key in pointInfos1.keys():
            for point in pointInfos1[key]:
                currentDict = {"layer": layerName1, "line id": key, "distance": point[0], "angle": point[1]}
                lrows1.append(currentDict)
        df1 = pd.DataFrame(lrows1)
        # dataframe for 2nd layer
        lrows2 = []
        for key in pointInfos2.keys():
            for point in pointInfos2[key]:
                currentDict = {"layer": layerName2, "line id": key, "distance": point[0], "angle": point[1]}
                lrows2.append(currentDict)
        df2 = pd.DataFrame(lrows2)
        df = pd.concat([df1, df2])
        return df, df1, df2
    
    # create line plot with distance as x and angle as y, for the 2 layers
    # this step is optional, only for visualising results
    def plotLine(self, df):
        # create plot
        fig = px.line(df, x = "distance", y = "angle", color = "layer", line_group = "line id", hover_name = "line id")
        # sets min, max and step for the axes
        fig.update_layout(xaxis_range=[0, 1])
        fig.update_layout(yaxis_range=[0, 360])
        fig.update_yaxes(tick0=0, dtick=45)
        # show plot in web browser
        fig.show()
     
    # from dataframes df1 and df2, create dataframe with statistical results
    # one row per line id, one column per statistical test
    def getStatResults(self, df1, df2, lineIds1):
        # empty list for lines to add to dfResults
        rows_list = []
        # for each couple of lines with same id 
        for lineId in lineIds1:
            QgsMessageLog.logMessage(('lineId : ' + str(lineId)), 'LineSimilarity')
            # create empty dic for current line id results
            lineResults = {}
            # add line id in lineResults
            lineResults['line id'] = lineId
            # get line with current id for layer 1
            line1 = df1.loc[df1['line id'] == lineId]
            line1 = list(line1['angle'])
            # get line with current id for layer 2
            line2 = df2.loc[df2['line id'] == lineId]
            line2 = list(line2['angle'])
            QgsMessageLog.logMessage(('line1 : ' + str(line1)), 'LineSimilarity')
            QgsMessageLog.logMessage(('line2 : ' + str(line2)), 'LineSimilarity')
            # Spearman test
            statSpearman, pvalueSpearman = stats.spearmanr(line1, line2)
            lineResults['Spearman'] = round(statSpearman, 6)
            lineResults['Spearman p-value'] = round(pvalueSpearman, 6)
            # Shapiro test
            statShapiro, pvalueShapiro = stats.shapiro(line1)
            lineResults['Shapiro line 1'] = round(statShapiro, 6)
            lineResults['Shapiro p-value line 1'] = round(pvalueShapiro, 6)
            statShapiro, pvalueShapiro = stats.shapiro(line2)
            lineResults['Shapiro line 2'] = round(statShapiro, 6)
            lineResults['Shapiro p-value line 2'] = round(pvalueShapiro, 6)
            # Student Test
            statStudent, pvalueStudent = stats.ttest_rel(line1, line2)
            lineResults['Student'] = round(statStudent, 6)
            lineResults['Student p-value'] = round(pvalueStudent, 6)
            # perform Wilocoxon test
            statWilcoxon, pvalueWilcoxon = stats.wilcoxon(line1, line2)
            lineResults['Wilcoxon'] = round(statWilcoxon, 6)
            lineResults['Wilcoxon p-value'] = round(pvalueWilcoxon, 6)
            # add current line results to dfResults
            rows_list.append(lineResults)
        # add all line to final df
        dfResults = pd.DataFrame(rows_list)
        return dfResults
        
#    # calculate correlation between the 2 variables with Spearman coefficient
#    def corrSpearman(self, dfCorr1, dfCorr2):
#        # supprime la colonne x de chaque dataframe
#        dfSpearman1 = dfCorr1.drop(columns = ['x'])
#        dfSpearman2 = dfCorr2.drop(columns = ['x'])
#        # convertit le dataframe en array numpy
#        arraySpearman1 = dfSpearman1.values
#        arraySpearman2 = dfSpearman2.values
#        # Spearman
#        statSpearman, pvalueSpearman = stats.spearmanr(arraySpearman1, arraySpearman2)
#        return statSpearman, pvalueSpearman
#    
#    # calculate Shapiro test to know if it's ok to proceed with Student test
#    def shapiroTest(self, dfCorr):
#        dfShapiro = pd.concat([dfCorr['y1'], dfCorr['y2']], axis = 1, keys=['y1', 'y2'])
#        statShapiro, pvalueShapiro = stats.shapiro(dfShapiro)
#        return statShapiro, pvalueShapiro
#    
#    # calculate correlation between the 2 variables with paired Student test
#    def studentTest(self, dfCorr):
#        statStudent, pvalueStudent = stats.ttest_rel(dfCorr['y1'], dfCorr['y2'])
#        return statStudent, pvalueStudent
#    
#    # calculate correlation between the 2 variables with Wilcoxon test
#    def wilcoxonTest(self, dfCorr):
#        statWilcoxon, pvalueWilcoxon = stats.wilcoxon(dfCorr['y1'], dfCorr['y2'])
#        return statWilcoxon, pvalueWilcoxon
    
    # create CSV file form result array
    def createCSV(self, output_folder, csv_name, csv_content):
        csv_file = output_folder + '/' + csv_name + ".csv"
        #np.savetxt(csv_name, csv_content, delimiter=",")
        pd.DataFrame(csv_content).to_csv(csv_file, index=False)
    
#    def createHTML(self, outputFile, results, layer1, layer2):
#        with codecs.open(outputFile, 'w', encoding='utf-8') as f:
#            f.write('<html><head>\n')
#            f.write('<meta http-equiv="Content-Type" content="text/html; \
#                    charset=utf-8" /></head><body>\n')
#            entete = 'calcul de similarité entre %s et %s :\n' % (layer1, layer2)
#            f.write(entete)
#            for k, v in results.items():
#                f.write('<p>' + str(k) + ' : ' + str(v) + '</p>\n')
#            f.write('</body></html>\n')
            
    def shortHelpString(self):
        return self.tr('''This algorithm takes 2 line layers as input, with only 1 entity in each layer. Layers are standardised and then compared using spearman correlation coefficient. Output is spearman coefficient and p-value, and a plot of the 2 standardised lines. The result is independant of rotation, scale and translation.''')
    
    def helpUrl(self):
        return "https://github.com/juliepierson/qgis_line_similarity"

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Line similarity'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LineSimilarityAlgorithm()
